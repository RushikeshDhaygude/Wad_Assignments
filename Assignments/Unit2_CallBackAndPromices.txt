Callback functions are commonly used in asynchronous programming to handle the completion of tasks. While they are widely used and effective in many scenarios, they also have some disadvantages:

1. **Callback Hell**: Asynchronous code often involves multiple nested callbacks, leading to a structure known as "callback hell." This can make the code difficult to read, understand, and maintain, especially as the number of nested callbacks increases.

2. **Error Handling**: Error handling in callback-based code can be cumbersome. Error propagation through nested callbacks can lead to error-handling code scattered throughout the codebase, making it harder to manage and debug.

3. **Difficulty with Control Flow**: Complex control flows, such as loops or conditional logic within asynchronous code, can be challenging to implement using callback functions. This can lead to convoluted and error-prone code.

4. **Readability and Maintainability**: Asynchronous code using callback functions can be harder to read and maintain compared to synchronous code or code using other asynchronous patterns.

One way to overcome the limitations of callback functions is by using promises. Promises provide a more structured and elegant way to work with asynchronous code. They offer several advantages:

1. **Readability**: Promises improve the readability of asynchronous code by providing a more linear and intuitive flow. Instead of nested callbacks, promises allow chaining of asynchronous operations using `.then()`.

2. **Error Handling**: Promises offer built-in error handling through the `.catch()` method, allowing you to handle errors in a centralized manner. This simplifies error handling and makes the code more maintainable.

3. **Control Flow**: Promises support easier control flow constructs, such as `Promise.all()` and `Promise.race()`, which allow you to coordinate multiple asynchronous operations or handle race conditions.

4. **Composition**: Promises are composable, meaning you can combine multiple asynchronous operations into a single promise chain, improving code modularity and reusability.

Here's an example demonstrating the use of promises in JavaScript:

```javascript
// Asynchronous function that returns a promise
function fetchData(url) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            // Simulate fetching data from the server
            const data = { id: 1, name: 'John Doe' };
            // Resolve the promise with the fetched data
            resolve(data);
            // Uncomment the following line to simulate an error
            // reject(new Error('Failed to fetch data'));
        }, 1000);
    });
}

// Example usage of promises
fetchData('https://api.example.com/data')
    .then(data => {
        console.log('Data:', data);
        // Perform additional operations with the fetched data
    })
    .catch(error => {
        console.error('Error:', error);
    });
```

In this example:
- The `fetchData()` function returns a promise that resolves with the fetched data after a simulated delay.
- The promise is consumed using the `.then()` method to handle the successful fulfillment of the promise.
- Error handling is implemented using the `.catch()` method to handle any errors that occur during the asynchronous operation.

By using promises, the code becomes more readable, maintainable, and easier to reason about compared to callback-based approaches.